// Author:  Niels A.D.
// Project: gowarcraft3 (https://github.com/nielsAD/gowarcraft3)
// License: Mozilla Public License, v2.0

package w3gs

import (
	"hash/crc32"
	"io"
	"math"

	"go.dedis.ch/protobuf"

	"github.com/nielsAD/gowarcraft3/protocol"
)

func readPacketHeader(buf *protocol.Buffer) (byte, int) {
	var bsize = buf.Size()
	if bsize < 4 {
		return 0, -1
	}
	buf.Skip(1)
	var pid = buf.ReadUInt8()
	var psize = int(buf.ReadUInt16())
	if psize > bsize {
		return pid, -1
	}
	return pid, psize
}

func readPacketSize(buf *protocol.Buffer) int {
	var _, psize = readPacketHeader(buf)
	return psize
}

// UnknownPacket is used to store unknown packets.
type UnknownPacket struct {
	ID   byte
	Blob []byte
}

// Serialize encodes the struct into its binary form.
func (pkt *UnknownPacket) Serialize(buf *protocol.Buffer, enc *Encoding) error {
	buf.WriteUInt8(ProtocolSig)
	buf.WriteUInt8(pkt.ID)
	buf.WriteUInt16(uint16(4 + len(pkt.Blob)))
	buf.WriteBlob(pkt.Blob)
	return nil
}

// Deserialize decodes the binary data generated by Serialize.
func (pkt *UnknownPacket) Deserialize(buf *protocol.Buffer, enc *Encoding) error {
	var pid, size = readPacketHeader(buf)
	if size < 4 {
		return ErrInvalidPacketSize
	}

	pkt.ID = pid
	pkt.Blob = append(pkt.Blob[:0], buf.ReadBlob(size-4)...)

	return nil
}

// Ping implements the [0x01] W3GS_PING_FROM_HOST packet (S -> C).
//
// This is sent every 30 seconds to make sure that the client is still responsive.
//
// Format:
//
//    (UINT32) Ping (GetTickCount)
//
type Ping struct {
	Payload uint32
}

// Serialize encodes the struct into its binary form.
func (pkt *Ping) Serialize(buf *protocol.Buffer, enc *Encoding) error {
	buf.WriteUInt8(ProtocolSig)
	buf.WriteUInt8(PidPingFromHost)
	buf.WriteUInt16(8)
	buf.WriteUInt32(pkt.Payload)
	return nil
}

// Deserialize decodes the binary data generated by Serialize.
func (pkt *Ping) Deserialize(buf *protocol.Buffer, enc *Encoding) error {
	if readPacketSize(buf) != 8 {
		return ErrInvalidPacketSize
	}

	pkt.Payload = buf.ReadUInt32()

	return nil
}

// Pong implements the [0x46] W3GS_PONG_TO_HOST packet (C -> S).
//
// This is sent in response to 0x01 W3GS_PING_FROM_HOST.
//
// The pong value is just a copy of whatever was sent in SEND_W3GS_PING_FROM_HOST which was GetTicks( ) at the time of sending
// so as long as we trust that the client isn't trying to fake us out and mess with the pong value we can find the round trip time by simple subtraction
// (the subtraction is done elsewhere because the very first pong value seems to be 1 and we want to discard that one)
//
// Format:
//
//    (UINT32) Pong (copy of Ping payload)
//
type Pong struct {
	Ping
}

// Serialize encodes the struct into its binary form.
func (pkt *Pong) Serialize(buf *protocol.Buffer, enc *Encoding) error {
	var start = buf.Size()
	if err := pkt.Ping.Serialize(buf, enc); err != nil {
		return err
	}
	buf.WriteUInt8At(start+1, PidPongToHost)
	return nil
}

// PeerPing implements the [0x35] W3GS_PING_FROM_OTHERS packet (C -> C).
//
// Client requests an echo from another client (occurs every 10 seconds).
//
// Format:
//
//    (UINT32) Ping
//    (UINT32) Peer set  (see [0x37] W3GS_ClientInfo)
//    (UINT32) Game ticks
//
type PeerPing struct {
	Payload   uint32
	PeerSet   protocol.BitSet32
	GameTicks uint32
}

// Serialize encodes the struct into its binary form.
func (pkt *PeerPing) Serialize(buf *protocol.Buffer, enc *Encoding) error {
	buf.WriteUInt8(ProtocolSig)
	buf.WriteUInt8(PidPingFromOthers)
	buf.WriteUInt16(16)

	buf.WriteUInt32(pkt.Payload)
	buf.WriteUInt32(uint32(pkt.PeerSet))
	buf.WriteUInt32(pkt.GameTicks)

	return nil
}

// Deserialize decodes the binary data generated by Serialize.
func (pkt *PeerPing) Deserialize(buf *protocol.Buffer, enc *Encoding) error {
	if readPacketSize(buf) != 16 {
		return ErrInvalidPacketSize
	}

	pkt.Payload = buf.ReadUInt32()
	pkt.PeerSet = protocol.BitSet32(buf.ReadUInt32())
	pkt.GameTicks = buf.ReadUInt32()

	return nil
}

// PeerPong implements the [0x36] W3GS_PONG_TO_OTHERS packet (C -> C).
//
// This is sent in response to an echo from another client.
//
// Format:
//
//    (UINT32) Pong (copy of Ping payload)
//
type PeerPong struct {
	Ping
}

// Serialize encodes the struct into its binary form.
func (pkt *PeerPong) Serialize(buf *protocol.Buffer, enc *Encoding) error {
	var start = buf.Size()
	if err := pkt.Ping.Serialize(buf, enc); err != nil {
		return err
	}
	buf.WriteUInt8At(start+1, PidPongToOthers)
	return nil
}

// Join implements the [0x1E] W3GS_ReqJoin packet (C -> S).
//
// A client sends this to the host to enter the game lobby.
//
// The internal IP uses the Windows in_addr structure which is thus used by the sockaddr_in structure.
//
// Format:
//
//    (UINT32)   Host Counter (Game ID)
//    (UINT32)   Entry Key (used in LAN)
//     (UINT8)   Unknown (0x00)
//    (UINT16)   Listen Port
//    (UINT32)   Join counter
//    (STRING)   Player name
//     (UINT8)   Number of bytes that follow (0x01 < 1.29; 0x02 >= 1.29)
//     (UINT8)[] Unknown (0x00)
//    (UINT16)   AF_INET (0x02)
//    (UINT16)   Internal Port
//    (UINT32)   Internal IP
//    (UINT32)   Unknown (0x00)
//    (UINT32)   Unknown (0x00)
//
type Join struct {
	HostCounter  uint32
	EntryKey     uint32
	ListenPort   uint16
	JoinCounter  uint32
	PlayerName   string
	InternalAddr protocol.SockAddr
}

// Serialize encodes the struct into its binary form.
func (pkt *Join) Serialize(buf *protocol.Buffer, enc *Encoding) error {
	buf.WriteUInt8(ProtocolSig)
	buf.WriteUInt8(PidReqJoin)
	buf.WriteUInt16(uint16(39 + len(pkt.PlayerName)))

	buf.WriteUInt32(pkt.HostCounter)
	buf.WriteUInt32(pkt.EntryKey)

	buf.WriteUInt8(0)

	buf.WriteUInt16(pkt.ListenPort)
	buf.WriteUInt32(pkt.JoinCounter)
	buf.WriteCString(pkt.PlayerName)

	buf.WriteUInt8(2)
	buf.WriteUInt8(0)
	buf.WriteUInt8(0)

	if err := buf.WriteSockAddr(&pkt.InternalAddr); err != nil {
		return err
	}

	return nil
}

// Deserialize decodes the binary data generated by Serialize.
func (pkt *Join) Deserialize(buf *protocol.Buffer, enc *Encoding) error {
	var size = readPacketSize(buf)
	if size < 37 {
		return ErrInvalidPacketSize
	}

	pkt.HostCounter = buf.ReadUInt32()
	pkt.EntryKey = buf.ReadUInt32()

	if buf.ReadUInt8() != 0 {
		return ErrUnexpectedConst
	}

	pkt.ListenPort = buf.ReadUInt16()
	pkt.JoinCounter = buf.ReadUInt32()

	var err error
	if pkt.PlayerName, err = buf.ReadCString(); err != nil {
		return err
	}

	if size < 37+len(pkt.PlayerName) {
		return ErrInvalidPacketSize
	}

	var skip = int(buf.ReadUInt8())
	if size != 37+len(pkt.PlayerName)+skip {
		return ErrInvalidPacketSize
	}
	buf.Skip(skip)

	if pkt.InternalAddr, err = buf.ReadSockAddr(); err != nil {
		return err
	}

	return nil
}

// RejectJoin implements the [0x05] W3GS_RejectJoin packet (S -> C).
//
// This is sent in a response to a request to join the game lobby and indicates that the request was denied.
//
// Reason:
//
//    0x09 RejectJoin_FULL      The game lobby is full
//    0x07 RejectJoin_INVALID   There was an error in your request
//    0x10 RejectJoin_STARTED   The game has already been started
//    0x27 RejectJoin_WRONGPASS The password you sent was incorrect
//
// Format:
//
//    (UINT32) Reason
//
type RejectJoin struct {
	Reason RejectReason
}

// Serialize encodes the struct into its binary form.
func (pkt *RejectJoin) Serialize(buf *protocol.Buffer, enc *Encoding) error {
	buf.WriteUInt8(ProtocolSig)
	buf.WriteUInt8(PidRejectJoin)
	buf.WriteUInt16(8)
	buf.WriteUInt32(uint32(pkt.Reason))
	return nil
}

// Deserialize decodes the binary data generated by Serialize.
func (pkt *RejectJoin) Deserialize(buf *protocol.Buffer, enc *Encoding) error {
	if readPacketSize(buf) != 8 {
		return ErrInvalidPacketSize
	}

	pkt.Reason = RejectReason(buf.ReadUInt32())

	return nil
}

// SlotInfoJoin implements the [0x04] W3GS_SlotInfoJoin packet (S -> C).
//
// This is sent to tell the client about the game slots, upon entry of the lobby.
//
// Format:
//
//    Embedded [0x09] W3GS_SlotInfo:
//	    (UINT16)   Length of Slot data
//	     (UINT8)   Number of slots
//	     (UINT8)[] Slot data
//	    (UINT32)   Random seed
//	     (UINT8)   Slots layout
//	     (UINT8)   Number of player slots without observers
//
//     (UINT8) Player number
//    (UINT16) AF_INET (0x02)
//    (UINT16) Port
//    (UINT32) External IP
//    (UINT32) Unknown (0x00)
//    (UINT32) Unknown (0x00)
//
type SlotInfoJoin struct {
	SlotInfo
	PlayerID     uint8
	ExternalAddr protocol.SockAddr
}

// Serialize encodes the struct into its binary form.
func (pkt *SlotInfoJoin) Serialize(buf *protocol.Buffer, enc *Encoding) error {
	buf.WriteUInt8(ProtocolSig)
	buf.WriteUInt8(PidSlotInfoJoin)
	buf.WriteUInt16(uint16(30 + len(pkt.Slots)*9))

	pkt.SlotInfo.SerializeContent(buf, enc)
	buf.WriteUInt8(pkt.PlayerID)

	if err := buf.WriteSockAddr(&pkt.ExternalAddr); err != nil {
		return err
	}

	return nil
}

// Deserialize decodes the binary data generated by Serialize.
func (pkt *SlotInfoJoin) Deserialize(buf *protocol.Buffer, enc *Encoding) error {
	var size = readPacketSize(buf)
	if size < 23 {
		return ErrInvalidPacketSize
	}

	if err := pkt.SlotInfo.DeserializeContent(buf, enc); err != nil {
		return err
	}

	if size != 30+len(pkt.Slots)*9 && !(size == 23 && len(pkt.Slots) == 0) {
		return ErrInvalidPacketSize
	}

	pkt.PlayerID = buf.ReadUInt8()

	var err error
	if pkt.ExternalAddr, err = buf.ReadSockAddr(); err != nil {
		return err
	}

	return nil
}

// SlotInfo implements the [0x09] W3GS_SlotInfo packet (S -> C).
//
// This is sent for slot updates.
//
// The length of slot info should always be `0x0B`.
//
// Format:
//
//    (UINT16)   Length of Slot data
//     (UINT8)   Number of slots
//     (UINT8)[] Slot data
//    (UINT32)   Random seed (GetTickCount)
//     (UINT8)   Slots layout
//     (UINT8)   Number of player slots without observers
//
//    For each slot:
//       (UINT8) Player number
//       (UINT8) Download status
//       (UINT8) Slot status
//       (UINT8) Computer status
//       (UINT8) Team
//       (UINT8) Color
//       (UINT8) Race
//       (UINT8) Computer type
//       (UINT8) Handicap
//
type SlotInfo struct {
	Slots      []SlotData
	RandomSeed uint32
	SlotLayout SlotLayout
	NumPlayers uint8
}

// SlotData stores the info for a single game slot.
//
// Download status:
//
// - This is a percentage of their download progress. As such, this value can only be between 0 and 100.
//
// Slot status:
//
//    0x00 Open
//    0x01 Closed
//    0x02 Occupied
//
// Computer status:
//
//    0x00 Human
//    0x01 Computer
//
// Race:
//
//    0x01 Human
//    0x02 Orc
//    0x04 Night Elf
//    0x08 Undead
//    0x20 Random
//    0x40 Selectable
//
// Computer type:
//
//    0x00 Easy
//    0x01 Normal / Human
//    0x02 Hard
//
//  Format:
//
//    (UINT8) Player number
//    (UINT8) Download status
//    (UINT8) Slot status
//    (UINT8) Computer status
//    (UINT8) Team
//    (UINT8) Color
//    (UINT8) Race
//    (UINT8) Computer type
//    (UINT8) Handicap
//
type SlotData struct {
	PlayerID       uint8
	DownloadStatus uint8
	SlotStatus     SlotStatus
	Computer       bool
	Team           uint8
	Color          uint8
	Race           RacePref
	ComputerType   AI
	Handicap       uint8
}

// Serialize encodes the struct into its binary form.
func (pkt *SlotInfo) Serialize(buf *protocol.Buffer, enc *Encoding) error {
	buf.WriteUInt8(ProtocolSig)
	buf.WriteUInt8(PidSlotInfo)
	buf.WriteUInt16(uint16(13 + len(pkt.Slots)*9))

	pkt.SerializeContent(buf, enc)

	return nil
}

// Deserialize decodes the binary data generated by Serialize.
func (pkt *SlotInfo) Deserialize(buf *protocol.Buffer, enc *Encoding) error {
	var size = readPacketSize(buf)
	if size < 13 {
		return ErrInvalidPacketSize
	}

	if err := pkt.DeserializeContent(buf, enc); err != nil {
		return err
	}

	if size != 13+len(pkt.Slots)*9 {
		return ErrInvalidPacketSize
	}

	return nil
}

// SerializeContent encodes the struct into its binary form without packet ID.
func (pkt *SlotInfo) SerializeContent(buf *protocol.Buffer, enc *Encoding) {
	buf.WriteUInt16(uint16(7 + len(pkt.Slots)*9))
	buf.WriteUInt8(uint8(len(pkt.Slots)))

	for i := 0; i < len(pkt.Slots); i++ {
		buf.WriteUInt8(pkt.Slots[i].PlayerID)
		buf.WriteUInt8(pkt.Slots[i].DownloadStatus)
		buf.WriteUInt8(uint8(pkt.Slots[i].SlotStatus))
		buf.WriteBool8(pkt.Slots[i].Computer)
		buf.WriteUInt8(pkt.Slots[i].Team)
		buf.WriteUInt8(pkt.Slots[i].Color)
		buf.WriteUInt8(uint8(pkt.Slots[i].Race))
		buf.WriteUInt8(uint8(pkt.Slots[i].ComputerType))
		buf.WriteUInt8(uint8(pkt.Slots[i].Handicap))
	}

	buf.WriteUInt32(pkt.RandomSeed)
	buf.WriteUInt8(uint8(pkt.SlotLayout))
	buf.WriteUInt8(pkt.NumPlayers)
}

// DeserializeContent decodes the binary data generated by SerializeContent.
func (pkt *SlotInfo) DeserializeContent(buf *protocol.Buffer, enc *Encoding) error {
	var dataSize = int(buf.ReadUInt16())
	if dataSize == 0 {
		pkt.Slots = pkt.Slots[:0]
		pkt.RandomSeed = 0
		pkt.SlotLayout = 0
		pkt.NumPlayers = 0
		return nil
	}

	if buf.Size() < dataSize {
		return ErrInvalidPacketSize
	}

	var numSlots = int(buf.ReadUInt8())
	var slotSize = 9
	if numSlots > 0 {
		slotSize = (dataSize - 7) / numSlots
	}

	if dataSize != 7+numSlots*slotSize {
		return ErrInvalidPacketSize
	}

	if cap(pkt.Slots) < numSlots {
		pkt.Slots = make([]SlotData, 0, numSlots)
	}
	pkt.Slots = pkt.Slots[:numSlots]

	for i := 0; i < len(pkt.Slots); i++ {
		pkt.Slots[i].PlayerID = buf.ReadUInt8()
		pkt.Slots[i].DownloadStatus = buf.ReadUInt8()
		pkt.Slots[i].SlotStatus = SlotStatus(buf.ReadUInt8())
		pkt.Slots[i].Computer = buf.ReadBool8()
		pkt.Slots[i].Team = buf.ReadUInt8()
		pkt.Slots[i].Color = buf.ReadUInt8()
		pkt.Slots[i].Race = RacePref(buf.ReadUInt8())
		if slotSize > 7 {
			pkt.Slots[i].ComputerType = AI(buf.ReadUInt8())
		} else {
			pkt.Slots[i].ComputerType = ComputerNormal
		}
		if slotSize > 8 {
			pkt.Slots[i].Handicap = buf.ReadUInt8()
		} else {
			pkt.Slots[i].Handicap = 100
		}
	}

	pkt.RandomSeed = buf.ReadUInt32()
	pkt.SlotLayout = SlotLayout(buf.ReadUInt8())
	pkt.NumPlayers = buf.ReadUInt8()

	return nil
}

// PlayerInfo implements the [0x06] W3GS_PlayerInfo packet (S -> C).
//
// Tells a client about a player'buf information.
//
// The external and internal IP are always zero for the host.
//
// Format:
//
//    (UINT32)   Join Counter
//     (UINT8)   Player number
//    (STRING)   Player name
//     (UINT8)   Number of bytes that follow (0x01)
//     (UINT8)[] Unknown (0x00)
//    (UINT16)   AF_INET (0x02)
//    (UINT16)   Port
//    (UINT32)   External IP
//    (UINT32)   Unknown (0x00)
//    (UINT32)   Unknown (0x00)
//    (UINT16)   AF_INET (0x02)
//    (UINT16)   Port
//    (UINT32)   Internal IP
//    (UINT32)   Unknown (0x00)
//    (UINT32)   Unknown (0x00)
//
type PlayerInfo struct {
	JoinCounter  uint32
	PlayerID     uint8
	PlayerName   string
	ExternalAddr protocol.SockAddr
	InternalAddr protocol.SockAddr
}

// Serialize encodes the struct into its binary form.
func (pkt *PlayerInfo) Serialize(buf *protocol.Buffer, enc *Encoding) error {
	buf.WriteUInt8(ProtocolSig)
	buf.WriteUInt8(PidPlayerInfo)
	buf.WriteUInt16(uint16(44 + len(pkt.PlayerName)))

	buf.WriteUInt32(pkt.JoinCounter)
	buf.WriteUInt8(pkt.PlayerID)
	buf.WriteCString(pkt.PlayerName)

	buf.WriteUInt8(1)
	buf.WriteUInt8(0)

	if err := buf.WriteSockAddr(&pkt.ExternalAddr); err != nil {
		return err
	}
	if err := buf.WriteSockAddr(&pkt.InternalAddr); err != nil {
		return err
	}

	return nil
}

// Deserialize decodes the binary data generated by Serialize.
func (pkt *PlayerInfo) Deserialize(buf *protocol.Buffer, enc *Encoding) error {
	var size = readPacketSize(buf)
	if size < 43 {
		return ErrInvalidPacketSize
	}

	pkt.JoinCounter = buf.ReadUInt32()
	pkt.PlayerID = buf.ReadUInt8()

	var err error
	if pkt.PlayerName, err = buf.ReadCString(); err != nil {
		return err
	}
	if size < 43+len(pkt.PlayerName) {
		return ErrInvalidPacketSize
	}

	var skip = int(buf.ReadUInt8())
	if size != 43+len(pkt.PlayerName)+skip {
		return ErrInvalidPacketSize
	}
	buf.Skip(skip)

	if pkt.ExternalAddr, err = buf.ReadSockAddr(); err != nil {
		return err
	}
	if pkt.InternalAddr, err = buf.ReadSockAddr(); err != nil {
		return err
	}

	return nil
}

// Leave implements the [0x21] W3GS_LeaveReq packet (C -> S).
//
// A client requests to leave.
//
// Reason:
//
//    0x01 PLAYERLEAVE_DISCONNECT
//    0x07 PLAYERLEAVE_LOST
//    0x08 PLAYERLEAVE_LOSTBUILDINGS
//    0x09 PLAYERLEAVE_WON
//    0x0A PLAYERLEAVE_DRAW
//    0x0B PLAYERLEAVE_OBSERVER
//    0x0D PLAYERLEAVE_LOBBY
//
// Format:
//
//    (UINT32) Reason
//
type Leave struct {
	Reason LeaveReason
}

// Serialize encodes the struct into its binary form.
func (pkt *Leave) Serialize(buf *protocol.Buffer, enc *Encoding) error {
	buf.WriteUInt8(ProtocolSig)
	buf.WriteUInt8(PidLeaveReq)
	buf.WriteUInt16(8)
	buf.WriteUInt32(uint32(pkt.Reason))
	return nil
}

// Deserialize decodes the binary data generated by Serialize.
func (pkt *Leave) Deserialize(buf *protocol.Buffer, enc *Encoding) error {
	if readPacketSize(buf) != 8 {
		return ErrInvalidPacketSize
	}

	pkt.Reason = LeaveReason(buf.ReadUInt32())
	return nil
}

// PlayerKicked implements the [0x1C] W3GS_PlayerKicked packet (S -> C).
//
// The host has kicked the client from the lobby.
//
// Reason:
//
//    0x01 PLAYERLEAVE_DISCONNECT
//    0x07 PLAYERLEAVE_LOST
//    0x08 PLAYERLEAVE_LOSTBUILDINGS
//    0x09 PLAYERLEAVE_WON
//    0x0A PLAYERLEAVE_DRAW
//    0x0B PLAYERLEAVE_OBSERVER
//    0x0D PLAYERLEAVE_LOBBY
//
// Format:
//
//    (UINT32) Reason
//
type PlayerKicked struct {
	Leave
}

// Serialize encodes the struct into its binary form.
func (pkt *PlayerKicked) Serialize(buf *protocol.Buffer, enc *Encoding) error {
	var start = buf.Size()
	if err := pkt.Leave.Serialize(buf, enc); err != nil {
		return err
	}
	buf.WriteUInt8At(start+1, PidPlayerKicked)
	return nil
}

// LeaveAck implements the [0x1B] W3GS_LeaveAck packet (S -> C).
//
// This is the response to [0x21] W3GS_LeaveReq.
//
// You will leave the game once the connection is terminated.
//
// Format:
//
//    [blank]
//
type LeaveAck struct {
	// Empty
}

// Serialize encodes the struct into its binary form.
func (pkt *LeaveAck) Serialize(buf *protocol.Buffer, enc *Encoding) error {
	buf.WriteUInt8(ProtocolSig)
	buf.WriteUInt8(PidLeaveAck)
	buf.WriteUInt16(4)
	return nil
}

// Deserialize decodes the binary data generated by Serialize.
func (pkt *LeaveAck) Deserialize(buf *protocol.Buffer, enc *Encoding) error {
	if readPacketSize(buf) != 4 {
		return ErrInvalidPacketSize
	}
	return nil
}

// PlayerLeft implements the [0x07] W3GS_PlayerLeft packet (S -> C).
//
// This is received from the game host when a player leaves.
//
// Reason:
//
//    0x01 PLAYERLEAVE_DISCONNECT
//    0x07 PLAYERLEAVE_LOST
//    0x08 PLAYERLEAVE_LOSTBUILDINGS
//    0x09 PLAYERLEAVE_WON
//    0x0A PLAYERLEAVE_DRAW
//    0x0B PLAYERLEAVE_OBSERVER
//    0x0D PLAYERLEAVE_LOBBY
//
// Format:
//
//     (UINT8) Player number
//    (UINT32) Reason
//
type PlayerLeft struct {
	PlayerID uint8
	Reason   LeaveReason
}

// Serialize encodes the struct into its binary form.
func (pkt *PlayerLeft) Serialize(buf *protocol.Buffer, enc *Encoding) error {
	buf.WriteUInt8(ProtocolSig)
	buf.WriteUInt8(PidPlayerLeft)
	buf.WriteUInt16(9)
	buf.WriteUInt8(pkt.PlayerID)
	buf.WriteUInt32(uint32(pkt.Reason))
	return nil
}

// Deserialize decodes the binary data generated by Serialize.
func (pkt *PlayerLeft) Deserialize(buf *protocol.Buffer, enc *Encoding) error {
	if readPacketSize(buf) != 9 {
		return ErrInvalidPacketSize
	}

	pkt.PlayerID = buf.ReadUInt8()
	pkt.Reason = LeaveReason(buf.ReadUInt32())
	return nil
}

// CountDownStart implements the [0x0A] W3GS_COUNTDOWN_START packet (S -> C).
//
// The game has begun the countdown to start.
//
// The official clients countdown from 5 seconds, however it is possible to use any time you wish. For example, the GHost++ bot uses 10 seconds when auto-hosted, but 5 seconds when started using an administrative command.
//
// Format:
//
//    [blank]
//
type CountDownStart struct {
	// Empty
}

// Serialize encodes the struct into its binary form.
func (pkt *CountDownStart) Serialize(buf *protocol.Buffer, enc *Encoding) error {
	buf.WriteUInt8(ProtocolSig)
	buf.WriteUInt8(PidCountDownStart)
	buf.WriteUInt16(4)
	return nil
}

// Deserialize decodes the binary data generated by Serialize.
func (pkt *CountDownStart) Deserialize(buf *protocol.Buffer, enc *Encoding) error {
	if readPacketSize(buf) != 4 {
		return ErrInvalidPacketSize
	}
	return nil
}

// CountDownEnd implements the [0x0B] W3GS_COUNTDOWN_END packet (S -> C).
//
// The game has finished the countdown and has now started. Players should see a loading screen for the map once this is received.
//
// [0x0A] W3GS_COUNTDOWN_START should be received before this packet, even if there is no countdown or if the countdown was 0 seconds.
//
// Format:
//
//    [blank]
//
type CountDownEnd struct {
	// Empty
}

// Serialize encodes the struct into its binary form.
func (pkt *CountDownEnd) Serialize(buf *protocol.Buffer, enc *Encoding) error {
	buf.WriteUInt8(ProtocolSig)
	buf.WriteUInt8(PidCountDownEnd)
	buf.WriteUInt16(4)
	return nil
}

// Deserialize decodes the binary data generated by Serialize.
func (pkt *CountDownEnd) Deserialize(buf *protocol.Buffer, enc *Encoding) error {
	if readPacketSize(buf) != 4 {
		return ErrInvalidPacketSize
	}
	return nil
}

// GameLoaded implements the [0x23] W3GS_GAMELOADED_SELF packet (C -> S).
//
// The client sends this to the host when they have finished loading the map.
//
// Format:
//
//    [blank]
//
type GameLoaded struct {
	// Empty
}

// Serialize encodes the struct into its binary form.
func (pkt *GameLoaded) Serialize(buf *protocol.Buffer, enc *Encoding) error {
	buf.WriteUInt8(ProtocolSig)
	buf.WriteUInt8(PidGameLoadedSelf)
	buf.WriteUInt16(4)
	return nil
}

// Deserialize decodes the binary data generated by Serialize.
func (pkt *GameLoaded) Deserialize(buf *protocol.Buffer, enc *Encoding) error {
	if readPacketSize(buf) != 4 {
		return ErrInvalidPacketSize
	}
	return nil
}

// PlayerLoaded implements the [0x08] W3GS_PlayerLoaded packet (S -> C).
//
// Sent to all other clients in-game to notify that a player has finished loading.
//
// Format:
//
//    (UINT8) Player number
//
type PlayerLoaded struct {
	PlayerID uint8
}

// Serialize encodes the struct into its binary form.
func (pkt *PlayerLoaded) Serialize(buf *protocol.Buffer, enc *Encoding) error {
	buf.WriteUInt8(ProtocolSig)
	buf.WriteUInt8(PidPlayerLoaded)
	buf.WriteUInt16(5)
	buf.WriteUInt8(pkt.PlayerID)
	return nil
}

// Deserialize decodes the binary data generated by Serialize.
func (pkt *PlayerLoaded) Deserialize(buf *protocol.Buffer, enc *Encoding) error {
	if readPacketSize(buf) != 5 {
		return ErrInvalidPacketSize
	}

	pkt.PlayerID = buf.ReadUInt8()
	return nil
}

// GameOver implements the [0x14] W3GS_GameOver packet (S -> C).
//
// Notify clients that the game has ended and the connection will be closed.
//
// Format:
//
//    (UINT8) Player number
//
type GameOver struct {
	PlayerID uint8
}

// Serialize encodes the struct into its binary form.
func (pkt *GameOver) Serialize(buf *protocol.Buffer, enc *Encoding) error {
	buf.WriteUInt8(ProtocolSig)
	buf.WriteUInt8(PidGameOver)
	buf.WriteUInt16(5)
	buf.WriteUInt8(pkt.PlayerID)
	return nil
}

// Deserialize decodes the binary data generated by Serialize.
func (pkt *GameOver) Deserialize(buf *protocol.Buffer, enc *Encoding) error {
	if readPacketSize(buf) != 5 {
		return ErrInvalidPacketSize
	}

	pkt.PlayerID = buf.ReadUInt8()
	return nil
}

// StartLag implements the [0x10] W3GS_START_LAG packet (S -> C).
//
// This is sent to the clients to initiate the lag screen.
//
// Format:
//
//    (UINT8) Number of lagging players
//
//    For every lagging player:
//        (UINT8) Player number
//       (UINT32) Lag duration in milliseconds
//
type StartLag struct {
	Players []LagPlayer
}

// Serialize encodes the struct into its binary form.
func (pkt *StartLag) Serialize(buf *protocol.Buffer, enc *Encoding) error {
	buf.WriteUInt8(ProtocolSig)
	buf.WriteUInt8(PidStartLag)
	buf.WriteUInt16(uint16(5 + len(pkt.Players)*5))

	buf.WriteUInt8(uint8(len(pkt.Players)))
	for i := 0; i < len(pkt.Players); i++ {
		pkt.Players[i].SerializeContent(buf, enc)
	}

	return nil
}

// Deserialize decodes the binary data generated by Serialize.
func (pkt *StartLag) Deserialize(buf *protocol.Buffer, enc *Encoding) error {
	var size = readPacketSize(buf)
	if size < 5 {
		return ErrInvalidPacketSize
	}

	var numPlayers = int(buf.ReadUInt8())

	if size != 5+numPlayers*5 {
		return ErrInvalidPacketSize
	}

	if cap(pkt.Players) < numPlayers {
		pkt.Players = make([]LagPlayer, 0, numPlayers)
	}
	pkt.Players = pkt.Players[:numPlayers]

	for i := 0; i < len(pkt.Players); i++ {
		pkt.Players[i].DeserializeContent(buf, enc)
	}

	return nil
}

// LagPlayer stores the data for a single lagging player.
//
//    (UINT8) Player number
//    (UINT32) Lag duration in milliseconds
//
type LagPlayer struct {
	PlayerID      uint8
	LagDurationMS uint32
}

// SerializeContent encodes the struct into its binary form without packet ID.
func (lp *LagPlayer) SerializeContent(buf *protocol.Buffer, enc *Encoding) {
	buf.WriteUInt8(lp.PlayerID)
	buf.WriteUInt32(lp.LagDurationMS)
}

// DeserializeContent decodes the binary data generated by SerializeContent.
func (lp *LagPlayer) DeserializeContent(buf *protocol.Buffer, enc *Encoding) {
	lp.PlayerID = buf.ReadUInt8()
	lp.LagDurationMS = buf.ReadUInt32()
}

// StopLag implements the [0x11] W3GS_STOP_LAG packet (S -> C).
//
// This is sent to the clients to indicate that a player stopped lagging.
//
// Format:
//
//     (UINT8) Player number
//    (UINT32) Lag duration in milliseconds
//
type StopLag struct {
	LagPlayer
}

// Serialize encodes the struct into its binary form.
func (pkt *StopLag) Serialize(buf *protocol.Buffer, enc *Encoding) error {
	buf.WriteUInt8(ProtocolSig)
	buf.WriteUInt8(PidStopLag)
	buf.WriteUInt16(9)

	pkt.LagPlayer.SerializeContent(buf, enc)

	return nil
}

// Deserialize decodes the binary data generated by Serialize.
func (pkt *StopLag) Deserialize(buf *protocol.Buffer, enc *Encoding) error {
	if readPacketSize(buf) != 9 {
		return ErrInvalidPacketSize
	}

	pkt.LagPlayer.DeserializeContent(buf, enc)
	return nil
}

// DropLaggers implements the [0x2F] W3GS_STOP_DROPREQ packet (C -> S).
//
// This is sent when a player votes to drop lagging players.
//
// Format:
//
//    [blank]
//
type DropLaggers struct {
	// Empty
}

// Serialize encodes the struct into its binary form.
func (pkt *DropLaggers) Serialize(buf *protocol.Buffer, enc *Encoding) error {
	buf.WriteUInt8(ProtocolSig)
	buf.WriteUInt8(PidDropReq)
	buf.WriteUInt16(4)
	return nil
}

// Deserialize decodes the binary data generated by Serialize.
func (pkt *DropLaggers) Deserialize(buf *protocol.Buffer, enc *Encoding) error {
	if readPacketSize(buf) != 4 {
		return ErrInvalidPacketSize
	}
	return nil
}

// GameAction implements the [0x26] W3GS_OUTGOING_ACTION packet (C -> S).
//
// A client sends this to the game host to execute an action in-game.
//
// Format:
//
//    (UINT32) CRC-32 checksum
//      (VOID) Action data
//
type GameAction struct {
	Data []byte
}

// Serialize encodes the struct into its binary form.
func (pkt *GameAction) Serialize(buf *protocol.Buffer, enc *Encoding) error {
	buf.WriteUInt8(ProtocolSig)
	buf.WriteUInt8(PidOutgoingAction)
	buf.WriteUInt16(uint16(8 + len(pkt.Data)))

	buf.WriteUInt32(uint32(crc32.ChecksumIEEE(pkt.Data)))
	buf.WriteBlob(pkt.Data)

	return nil
}

// Deserialize decodes the binary data generated by Serialize.
func (pkt *GameAction) Deserialize(buf *protocol.Buffer, enc *Encoding) error {
	var size = readPacketSize(buf)
	if size < 8 {
		return ErrInvalidPacketSize
	}

	var crc = buf.ReadUInt32()
	pkt.Data = append(pkt.Data[:0], buf.ReadBlob(size-8)...)

	if crc != uint32(crc32.ChecksumIEEE(pkt.Data)) {
		return ErrInvalidChecksum
	}

	return nil
}

// TimeSlot implements the [0x0C] W3GS_INCOMING_ACTION packet (S -> C).
//
// Informs the client about an action in-game.
//
// Format:
//
//    (UINT16) Send interval
//    (UINT16) CRC-16 checksum
//
//    For each action:
//        (UINT8) Player number
//       (UINT16) Length of action data
//         (VOID) Action data
//
type TimeSlot struct {
	Fragment        bool
	TimeIncrementMS uint16
	Actions         []PlayerAction
}

// PlayerAction stores the data for a single game action.
//
//    (UINT8) Player number
//    (UINT16) Length of action data
//    (VOID) Action data
//
type PlayerAction struct {
	PlayerID uint8
	Data     []byte
}

// Serialize encodes the struct into its binary form.
func (pkt *TimeSlot) Serialize(buf *protocol.Buffer, enc *Encoding) error {
	var start = buf.Size()
	buf.WriteUInt8(ProtocolSig)

	if pkt.Fragment {
		buf.WriteUInt8(PidIncomingAction2)
	} else {
		buf.WriteUInt8(PidIncomingAction)
	}

	// Placeholder for size
	buf.WriteUInt16(0)

	buf.WriteUInt16(pkt.TimeIncrementMS)

	// Placeholder for CRC
	buf.WriteUInt16(0)

	for i := 0; i < len(pkt.Actions); i++ {
		buf.WriteUInt8(pkt.Actions[i].PlayerID)
		buf.WriteUInt16(uint16(len(pkt.Actions[i].Data)))
		buf.WriteBlob(pkt.Actions[i].Data)
	}

	// Set size
	buf.WriteUInt16At(start+2, uint16(buf.Size()-start))

	// Set CRC
	buf.WriteUInt16At(start+6, uint16(crc32.ChecksumIEEE(buf.Bytes[start+8:])))

	return nil
}

// Deserialize decodes the binary data generated by Serialize.
func (pkt *TimeSlot) Deserialize(buf *protocol.Buffer, enc *Encoding) error {
	var pid, size = readPacketHeader(buf)
	if size < 6 {
		return ErrInvalidPacketSize
	}

	pkt.Fragment = pid == PidIncomingAction2
	pkt.TimeIncrementMS = buf.ReadUInt16()

	if size == 6 {
		pkt.Actions = nil
		return nil
	} else if size < 8 {
		return ErrInvalidPacketSize
	}

	size -= 8

	var crc = buf.ReadUInt16()
	if crc != uint16(crc32.ChecksumIEEE(buf.Bytes[:size])) {
		return ErrInvalidChecksum
	}

	var i = 0

	pkt.Actions = pkt.Actions[:0]
	for size >= 3 {
		if cap(pkt.Actions) < i+1 {
			pkt.Actions = append(pkt.Actions, PlayerAction{})
		} else {
			pkt.Actions = pkt.Actions[:i+1]
		}

		pkt.Actions[i].PlayerID = buf.ReadUInt8()

		var subsize = int(buf.ReadUInt16())
		if size < subsize {
			return ErrInvalidPacketSize
		}
		size -= 3 + subsize

		pkt.Actions[i].Data = append(pkt.Actions[i].Data[:0], buf.ReadBlob(subsize)...)
		i++
	}

	if size != 0 {
		return ErrInvalidPacketSize
	}

	return nil
}

// TimeSlotAck implements the [0x27] W3GS_OUTGOING_KEEPALIVE packet (C -> S).
//
// This is sent to the host from each client.
//
// Format:
//
//    (UINT8)  Unknown
//    (UINT32) Unknown (checksum?)
//
type TimeSlotAck struct {
	Unknown1 uint8
	Checksum uint32
}

// Serialize encodes the struct into its binary form.
func (pkt *TimeSlotAck) Serialize(buf *protocol.Buffer, enc *Encoding) error {
	buf.WriteUInt8(ProtocolSig)
	buf.WriteUInt8(PidOutgoingKeepAlive)
	buf.WriteUInt16(9)
	buf.WriteUInt8(pkt.Unknown1)
	buf.WriteUInt32(pkt.Checksum)
	return nil
}

// Deserialize decodes the binary data generated by Serialize.
func (pkt *TimeSlotAck) Deserialize(buf *protocol.Buffer, enc *Encoding) error {
	if readPacketSize(buf) != 9 {
		return ErrInvalidPacketSize
	}

	pkt.Unknown1 = buf.ReadUInt8()
	pkt.Checksum = buf.ReadUInt32()
	return nil
}

// Desync implements the [0x0D] W3GS_DESYNC packet (S -> C).
//
// This is sent whenever the server detects a split state based on checksums sent
// by [0x27] W3GS_OUTGOING_KEEPALIVE. Each client continues the game with the
// given player numbers, other players are dropped.
//
//    (UINT32)  Unknown (0x01)
//    (UINT8)   Unknown (0x04)
//    (UINT32)  Checksum
//    (UINT8)   NumPlayersInState
//    (UINT8)[] Player numbers
//
type Desync struct {
	Unknown1       uint32
	Checksum       uint32
	PlayersInState []uint8
}

// Serialize encodes the struct into its binary form.
func (pkt *Desync) Serialize(buf *protocol.Buffer, enc *Encoding) error {
	buf.WriteUInt8(ProtocolSig)
	buf.WriteUInt8(PidDesync)
	buf.WriteUInt16(uint16(14 + len(pkt.PlayersInState)))
	pkt.SerializeContent(buf, enc)
	return nil
}

// Deserialize decodes the binary data generated by Serialize.
func (pkt *Desync) Deserialize(buf *protocol.Buffer, enc *Encoding) error {
	var size = readPacketSize(buf)
	if size < 14 {
		return ErrInvalidPacketSize
	}

	if err := pkt.DeserializeContent(buf, enc); err != nil {
		return err
	}
	if size != 14+len(pkt.PlayersInState) {
		return ErrInvalidPacketSize
	}

	return nil
}

// SerializeContent encodes the struct into its binary form without packet ID.
func (pkt *Desync) SerializeContent(buf *protocol.Buffer, enc *Encoding) {
	buf.WriteUInt32(pkt.Unknown1)
	buf.WriteUInt8(4)
	buf.WriteUInt32(pkt.Checksum)
	buf.WriteUInt8(uint8(len(pkt.PlayersInState)))
	buf.WriteBlob(pkt.PlayersInState)
}

// DeserializeContent decodes the binary data generated by SerializeContent.
func (pkt *Desync) DeserializeContent(buf *protocol.Buffer, enc *Encoding) error {
	pkt.Unknown1 = buf.ReadUInt32()
	if buf.ReadUInt8() != 4 {
		return ErrUnexpectedConst
	}
	pkt.Checksum = buf.ReadUInt32()

	var numPlayers = int(buf.ReadUInt8())
	if buf.Size() < numPlayers {
		return ErrInvalidPacketSize
	}

	pkt.PlayersInState = append(pkt.PlayersInState[:0], buf.ReadBlob(numPlayers)...)
	return nil
}

// Message implements the [0x28] W3GS_CHAT_TO_HOST packet (C -> S).
//
// This is sent from the client to the host to send a message to the other clients.
//
// Format:
//
//    (UINT8)   Player count
//    (UINT8)[] Player numbers that will receive the message
//    (UINT8)   From player number
//    (UINT8)   Flags
//
//    For Flag 0x10:
//       (STRING) Message
//    For Flag 0x11:
//       (UINT8) NewVal (Team)
//    For Flag 0x12:
//       (UINT8) NewVal (Color)
//    For Flag 0x13:
//       (UINT8) NewVal (Race)
//    For Flag 0x14:
//       (UINT8) NewVal(Handicap)
//    For Flag 0x20:
//       (UINT32) Message scope (0x00 all, 0x01 allies, 0x02 observers, else directed to N-0x03)
//       (STRING) Message
//
type Message struct {
	RecipientIDs []uint8
	SenderID     uint8
	Type         MessageType
	Scope        MessageScope
	NewVal       uint8
	Content      string
}

// Serialize encodes the struct into its binary form.
func (pkt *Message) Serialize(buf *protocol.Buffer, enc *Encoding) error {
	buf.WriteUInt8(ProtocolSig)
	buf.WriteUInt8(PidChatToHost)

	switch pkt.Type {
	case MsgChatExtra:
		buf.WriteUInt16(uint16(12 + len(pkt.RecipientIDs) + len(pkt.Content)))
	case MsgChat:
		buf.WriteUInt16(uint16(8 + len(pkt.RecipientIDs) + len(pkt.Content)))
	default:
		buf.WriteUInt16(uint16(8 + len(pkt.RecipientIDs)))
	}

	buf.WriteUInt8(uint8(len(pkt.RecipientIDs)))
	buf.WriteBlob(pkt.RecipientIDs)
	buf.WriteUInt8(pkt.SenderID)
	buf.WriteUInt8(uint8(pkt.Type))

	switch pkt.Type {
	case MsgChatExtra:
		buf.WriteUInt32(uint32(pkt.Scope))
		fallthrough
	case MsgChat:
		buf.WriteCString(pkt.Content)
	default:
		buf.WriteUInt8(pkt.NewVal)
	}

	return nil
}

// Deserialize decodes the binary data generated by Serialize.
func (pkt *Message) Deserialize(buf *protocol.Buffer, enc *Encoding) error {
	var size = readPacketSize(buf)
	if size < 8 {
		return ErrInvalidPacketSize
	}

	var numRecipients = int(buf.ReadUInt8())
	if size < 8+numRecipients {
		return ErrInvalidPacketSize
	}

	pkt.RecipientIDs = append(pkt.RecipientIDs[:0], buf.ReadBlob(numRecipients)...)
	pkt.SenderID = buf.ReadUInt8()
	pkt.Type = MessageType(buf.ReadUInt8())

	pkt.Scope = ScopeAll
	pkt.NewVal = 0
	pkt.Content = ""

	switch pkt.Type {
	case MsgChatExtra:
		if size < 12+numRecipients {
			return ErrInvalidPacketSize
		}
		size -= 4
		pkt.Scope = MessageScope(buf.ReadUInt32())
		fallthrough
	case MsgChat:
		var err error
		if pkt.Content, err = buf.ReadCString(); err != nil {
			return err
		}
		if size != 8+numRecipients+len(pkt.Content) {
			return ErrInvalidPacketSize
		}
	default:
		if size != 8+numRecipients {
			return ErrInvalidPacketSize
		}
		pkt.NewVal = buf.ReadUInt8()
	}

	return nil
}

// MessageRelay implements the [0x0F] W3GS_CHAT_FROM_HOST packet (S -> C).
//
// This is sent to the clients to print a message on the screen from another player.
//
// Format:
//
//    (UINT8)   Player count
//    (UINT8)[] Player numbers that will receive the message
//    (UINT8)   From player number
//    (UINT8)   Flags
//
//    For Flag 0x10:
//       (STRING) Message
//    For Flag 0x11:
//       (UINT8) NewVal (Team)
//    For Flag 0x12:
//       (UINT8) NewVal (Color)
//    For Flag 0x13:
//       (UINT8) NewVal (Race)
//    For Flag 0x14:
//       (UINT8) NewVal(Handicap)
//    For Flag 0x20:
//       (UINT32) Extra Flags
//       (STRING) Message
//
type MessageRelay struct {
	Message
}

// Serialize encodes the struct into its binary form.
func (pkt *MessageRelay) Serialize(buf *protocol.Buffer, enc *Encoding) error {
	var start = buf.Size()
	if err := pkt.Message.Serialize(buf, enc); err != nil {
		return err
	}
	buf.WriteUInt8At(start+1, PidChatFromHost)
	return nil
}

// PeerMessage implements the [0x34] W3GS_CHAT_FROM_OTHERS packet (C -> C).
//
// This is sent to connected peers to print a message on the screen from another player.
//
// Format:
//
//    (UINT8)   Player count
//    (UINT8)[] Player numbers that will receive the message
//    (UINT8)   From player number
//    (UINT8)   Flags
//
//    For Flag 0x10:
//       (STRING) Message
//    For Flag 0x11:
//       (UINT8) NewVal (Team)
//    For Flag 0x12:
//       (UINT8) NewVal (Color)
//    For Flag 0x13:
//       (UINT8) NewVal (Race)
//    For Flag 0x14:
//       (UINT8) NewVal(Handicap)
//    For Flag 0x20:
//       (UINT32) Extra Flags
//       (STRING) Message
//
type PeerMessage struct {
	Message
}

// Serialize encodes the struct into its binary form.
func (pkt *PeerMessage) Serialize(buf *protocol.Buffer, enc *Encoding) error {
	var start = buf.Size()
	if err := pkt.Message.Serialize(buf, enc); err != nil {
		return err
	}
	buf.WriteUInt8At(start+1, PidChatFromOthers)
	return nil
}

// SearchGame implements the [0x2F] W3GS_SearchGame packet (C -> S).
//
// This is broadcasted to the entire local area network to detect games during initial
// search of local games. After that, it is sent directly to clients that broadcasted
// [0x31] W3GS_CreateGame.
//
// Product is either WAR3 or W3XP.
//
// Format:
//
//    (UINT32) Product
//    (UINT32) Version
//    (UINT32) Host Counter
//
type SearchGame struct {
	GameVersion
	HostCounter uint32
}

// Serialize encodes the struct into its binary form.
func (pkt *SearchGame) Serialize(buf *protocol.Buffer, enc *Encoding) error {
	buf.WriteUInt8(ProtocolSig)
	buf.WriteUInt8(PidSearchGame)
	buf.WriteUInt16(16)

	pkt.GameVersion.SerializeContent(buf, enc)
	buf.WriteUInt32(pkt.HostCounter)

	return nil
}

// Deserialize decodes the binary data generated by Serialize.
func (pkt *SearchGame) Deserialize(buf *protocol.Buffer, enc *Encoding) error {
	if readPacketSize(buf) != 16 {
		return ErrInvalidPacketSize
	}

	pkt.GameVersion.DeserializeContent(buf, enc)
	pkt.HostCounter = buf.ReadUInt32()

	return nil
}

// GameVersion stores the game version tuple.
//
//  Format:
//    (UINT32) Product
//    (UINT32) Version
//
type GameVersion struct {
	Product protocol.DWordString
	Version uint32
}

// SerializeContent encodes the struct into its binary form without packet ID.
func (gv *GameVersion) SerializeContent(buf *protocol.Buffer, enc *Encoding) {
	buf.WriteBEDString(gv.Product)
	buf.WriteUInt32(gv.Version)
}

// DeserializeContent decodes the binary data generated by SerializeContent.
func (gv *GameVersion) DeserializeContent(buf *protocol.Buffer, enc *Encoding) {
	gv.Product = buf.ReadBEDString()
	gv.Version = buf.ReadUInt32()
}

// GameSettings stores the settings of a created game.
//
// Flags:
//
//   Speed: (mask 0x00000003) cannot be combined
//     0x00000000 - Slow game speed
//     0x00000001 - Normal game speed
//     0x00000002 - Fast game speed
//   Visibility: (mask 0x00000F00) cannot be combined
//     0x00000100 - Hide terrain
//     0x00000200 - Map explored
//     0x00000400 - Always visible (no fog of war)
//     0x00000800 - Default
//   Observers/Referees: (mask 0x40003000) cannot be combined
//     0x00000000 - No Observers
//     0x00002000 - Observers on Defeat
//     0x00003000 - Additional players as observer allowed
//     0x40000000 - Referees
//   Teams/Units/Hero/Race: (mask 0x07064000) can be combined
//     0x00004000 - Teams Together (team members are placed at neighbored starting locations)
//     0x00060000 - Fixed teams
//     0x01000000 - Unit share
//     0x02000000 - Random hero
//     0x04000000 - Random races
//
// Format:
//
//    (UINT32)     Flags
//    (UINT16)     Map width
//    (UINT16)     Map height
//    (UINT32)     Map xoro
//    (STRING)     Map path
//    (STRING)     Host name
//     (UINT8)[20] Map Sha1 hash
//
// Encoded as a null terminated string where every even byte-value was
// incremented by 1. So all encoded bytes are odd. A control-byte stores
// the transformations for the next 7 bytes.
//
type GameSettings struct {
	GameSettingFlags GameSettingFlags
	MapWidth         uint16
	MapHeight        uint16
	MapXoro          uint32
	MapPath          string
	HostName         string
	MapSha1          [20]byte
}

// Size of Serialize()
func (gs *GameSettings) Size() int {
	var size = 36 + len(gs.MapPath) + len(gs.HostName)
	return size + int(math.Ceil(float64(size)/7)) + 1
}

// SerializeContent GameSettings into StatString
func (gs *GameSettings) SerializeContent(buf *protocol.Buffer, enc *Encoding) {
	var statstring = protocol.Buffer{Bytes: make([]byte, 0, 36+len(gs.MapPath)+len(gs.HostName))}
	statstring.WriteUInt32(uint32(gs.GameSettingFlags))
	statstring.WriteUInt8(0)
	statstring.WriteUInt16(gs.MapWidth)
	statstring.WriteUInt16(gs.MapHeight)
	statstring.WriteUInt32(gs.MapXoro)
	statstring.WriteCString(gs.MapPath)
	statstring.WriteCString(gs.HostName)
	statstring.WriteUInt8(0)
	statstring.WriteBlob(gs.MapSha1[:])

	var b = statstring.Bytes[:]
	for i := uint(0); i < uint(len(b)); i += 7 {
		var p = buf.Size()
		var m = uint8(1)
		buf.WriteUInt8(0)

		for j := uint(0); j < 7 && i+j < uint(len(b)); j++ {
			if (b[i+j] % 2) == 0 {
				buf.WriteUInt8(b[i+j] + 1)
			} else {
				buf.WriteUInt8(b[i+j])
				m |= 1 << (j + 1)
			}
		}

		buf.WriteUInt8At(p, m)
	}
	buf.WriteUInt8(0)
}

// DeserializeContent GameSettings from StatString
func (gs *GameSettings) DeserializeContent(buf *protocol.Buffer, enc *Encoding) error {
	var statstring string
	var err error
	if statstring, err = buf.ReadCString(); err != nil {
		return err
	}

	if len(statstring) < 16 {
		return ErrInvalidPacketSize
	}

	var b = protocol.Buffer{Bytes: make([]byte, 0, len(statstring))}
	for i := uint(0); i < uint(len(statstring)); i += 8 {
		var m = uint8(statstring[i])

		for j := uint(1); j <= 7 && i+j < uint(len(statstring)); j++ {
			if m&(1<<j) == 0 {
				b.WriteUInt8(uint8(statstring[i+j]) - 1)
			} else {
				b.WriteUInt8(uint8(statstring[i+j]))
			}
		}
	}

	var size = b.Size()
	gs.GameSettingFlags = GameSettingFlags(b.ReadUInt32())

	// Unknown enum, perhaps type of game (online / local / lan)?
	switch b.ReadUInt8() {
	case 0, 1, 2:
	default:
		return ErrUnexpectedConst
	}

	gs.MapWidth = b.ReadUInt16()
	gs.MapHeight = b.ReadUInt16()
	gs.MapXoro = b.ReadUInt32()

	gs.MapPath, err = b.ReadCString()
	if err != nil {
		return err
	}
	if size < 16+len(gs.MapPath) {
		return ErrInvalidPacketSize
	}

	gs.HostName, err = b.ReadCString()
	if err != nil {
		return err
	}

	size -= 16 + len(gs.MapPath) + len(gs.HostName)
	if size != 0 && size != 20 {
		return ErrInvalidPacketSize
	}

	if b.ReadUInt8() != 0 {
		return ErrUnexpectedConst
	}

	if size != 0 {
		copy(gs.MapSha1[:], b.ReadBlob(20))
	} else {
		gs.MapSha1 = [20]byte{}
	}

	return nil
}

// GameInfo implements the [0x30] W3GS_GameInfo packet (S -> C).
//
// This is sent in response to [0x2F] W3GS_SearchGame (on the local area network).
//
// Format:
//
//    (UINT32) Product
//    (UINT32) Version
//    (UINT32) Host Counter
//    (UINT32) Entry key
//    (STRING) Game name
//     (UINT8) Unknown (0x00)
//    (STRING) Statstring
//    (UINT32) Slots total
//    (UINT32) Game Type Info
//    (UINT32) Player slots used
//    (UINT32) Player slots available (total slots - closed slots - AI slots)
//    (UINT32) Time since creation
//    (UINT16) Listen Port
//
type GameInfo struct {
	GameVersion
	HostCounter    uint32
	EntryKey       uint32
	GameName       string
	GameSettings   GameSettings
	SlotsTotal     uint32
	GameFlags      GameFlags
	SlotsUsed      uint32
	SlotsAvailable uint32
	UptimeSec      uint32
	GamePort       uint16
}

// Serialize encodes the struct into its binary form.
func (pkt *GameInfo) Serialize(buf *protocol.Buffer, enc *Encoding) error {
	buf.WriteUInt8(ProtocolSig)
	buf.WriteUInt8(PidGameInfo)
	buf.WriteUInt16(uint16(44 + len(pkt.GameName) + pkt.GameSettings.Size()))

	pkt.GameVersion.SerializeContent(buf, enc)
	buf.WriteUInt32(pkt.HostCounter)
	buf.WriteUInt32(pkt.EntryKey)
	buf.WriteCString(pkt.GameName)
	buf.WriteUInt8(0)
	pkt.GameSettings.SerializeContent(buf, enc)
	buf.WriteUInt32(pkt.SlotsTotal)
	buf.WriteUInt32(uint32(pkt.GameFlags))
	buf.WriteUInt32(pkt.SlotsUsed)
	buf.WriteUInt32(pkt.SlotsAvailable)
	buf.WriteUInt32(pkt.UptimeSec)
	buf.WriteUInt16(pkt.GamePort)

	return nil
}

// Deserialize decodes the binary data generated by Serialize.
func (pkt *GameInfo) Deserialize(buf *protocol.Buffer, enc *Encoding) error {
	var size = readPacketSize(buf)
	if size < 45 {
		return ErrInvalidPacketSize
	}

	pkt.GameVersion.DeserializeContent(buf, enc)
	pkt.HostCounter = buf.ReadUInt32()
	pkt.EntryKey = buf.ReadUInt32()

	var err error
	if pkt.GameName, err = buf.ReadCString(); err != nil {
		return err
	}
	if size < 45+len(pkt.GameName) {
		return ErrInvalidPacketSize
	}

	if buf.ReadUInt8() != 0 {
		return ErrUnexpectedConst
	}

	if err = pkt.GameSettings.DeserializeContent(buf, enc); err != nil {
		return err
	}
	if size != 44+len(pkt.GameName)+pkt.GameSettings.Size() {
		return ErrInvalidPacketSize
	}

	pkt.SlotsTotal = buf.ReadUInt32()
	pkt.GameFlags = GameFlags(buf.ReadUInt32())
	pkt.SlotsUsed = buf.ReadUInt32()
	pkt.SlotsAvailable = buf.ReadUInt32()
	pkt.UptimeSec = buf.ReadUInt32()
	pkt.GamePort = buf.ReadUInt16()

	return nil
}

// CreateGame implements the [0x31] W3GS_CreateGame packet (S -> C).
//
// Notifies the local area network that a game was created.
//
// Format:
//
//    (UINT32) Product
//    (UINT32) Version
//    (UINT32) HostCounter
//
type CreateGame struct {
	GameVersion
	HostCounter uint32
}

// Serialize encodes the struct into its binary form.
func (pkt *CreateGame) Serialize(buf *protocol.Buffer, enc *Encoding) error {
	buf.WriteUInt8(ProtocolSig)
	buf.WriteUInt8(PidCreateGame)
	buf.WriteUInt16(16)

	pkt.GameVersion.SerializeContent(buf, enc)
	buf.WriteUInt32(pkt.HostCounter)

	return nil
}

// Deserialize decodes the binary data generated by Serialize.
func (pkt *CreateGame) Deserialize(buf *protocol.Buffer, enc *Encoding) error {
	if readPacketSize(buf) != 16 {
		return ErrInvalidPacketSize
	}

	pkt.GameVersion.DeserializeContent(buf, enc)
	pkt.HostCounter = buf.ReadUInt32()

	return nil
}

// RefreshGame implements the [0x32] W3GS_RefreshGame packet (S -> C).
//
// Notifies the local area network about a game (occurs every 5 seconds or refresh slots).
//
// Format:
//
//    (UINT32) Host Counter
//    (UINT32) Player slots used
//    (UINT32) Player slots available (total slots - closed slots - AI slots)
//
type RefreshGame struct {
	HostCounter    uint32
	SlotsUsed      uint32
	SlotsAvailable uint32
}

// Serialize encodes the struct into its binary form.
func (pkt *RefreshGame) Serialize(buf *protocol.Buffer, enc *Encoding) error {
	buf.WriteUInt8(ProtocolSig)
	buf.WriteUInt8(PidRefreshGame)
	buf.WriteUInt16(16)

	buf.WriteUInt32(pkt.HostCounter)
	buf.WriteUInt32(pkt.SlotsUsed)
	buf.WriteUInt32(pkt.SlotsAvailable)

	return nil
}

// Deserialize decodes the binary data generated by Serialize.
func (pkt *RefreshGame) Deserialize(buf *protocol.Buffer, enc *Encoding) error {
	if readPacketSize(buf) != 16 {
		return ErrInvalidPacketSize
	}

	pkt.HostCounter = buf.ReadUInt32()
	pkt.SlotsUsed = buf.ReadUInt32()
	pkt.SlotsAvailable = buf.ReadUInt32()

	return nil
}

// DecreateGame implements the [0x33] W3GS_DecreateGame packet (S -> C).
//
// Notifies the local area network that a game is no longer being hosted.
//
// Format:
//
//    (UINT32) Host Counter
//
type DecreateGame struct {
	HostCounter uint32
}

// Serialize encodes the struct into its binary form.
func (pkt *DecreateGame) Serialize(buf *protocol.Buffer, enc *Encoding) error {
	buf.WriteUInt8(ProtocolSig)
	buf.WriteUInt8(PidDecreateGame)
	buf.WriteUInt16(8)
	buf.WriteUInt32(pkt.HostCounter)
	return nil
}

// Deserialize decodes the binary data generated by Serialize.
func (pkt *DecreateGame) Deserialize(buf *protocol.Buffer, enc *Encoding) error {
	if readPacketSize(buf) != 8 {
		return ErrInvalidPacketSize
	}

	pkt.HostCounter = buf.ReadUInt32()
	return nil
}

// PeerConnect implements the [0x37] W3GS_ClientInfo packet (C -> C).
//
// A client sends this to another client to gain information about self when connected.
//
// Peer set is a bitset with bits set for every peer connected to this client.
//
// Format:
//
//    (UINT32) Player Counter
//    (UINT32) Entry key
//     (UINT8) Player number
//     (UINT8) Unknown (0xFF, status / provider version constant?)
//    (UINT32) Peer set
//
type PeerConnect struct {
	JoinCounter uint32
	EntryKey    uint32
	PlayerID    uint8
	PeerSet     protocol.BitSet32
}

// Serialize encodes the struct into its binary form.
func (pkt *PeerConnect) Serialize(buf *protocol.Buffer, enc *Encoding) error {
	buf.WriteUInt8(ProtocolSig)
	buf.WriteUInt8(PidClientInfo)
	buf.WriteUInt16(18)

	buf.WriteUInt32(pkt.JoinCounter)
	buf.WriteUInt32(pkt.EntryKey)
	buf.WriteUInt8(pkt.PlayerID)

	buf.WriteUInt8(0xFF)
	buf.WriteUInt32(uint32(pkt.PeerSet))

	return nil
}

// Deserialize decodes the binary data generated by Serialize.
func (pkt *PeerConnect) Deserialize(buf *protocol.Buffer, enc *Encoding) error {
	if readPacketSize(buf) != 18 {
		return ErrInvalidPacketSize
	}

	pkt.JoinCounter = buf.ReadUInt32()
	pkt.EntryKey = buf.ReadUInt32()
	pkt.PlayerID = buf.ReadUInt8()

	if buf.ReadUInt8() != 0xFF {
		return ErrUnexpectedConst
	}

	pkt.PeerSet = protocol.BitSet32(buf.ReadUInt32())

	return nil
}

// PeerSet implements the [0x3B] W3GS_PEER_SET packet (C -> S).
//
// Client sends this to the server to let it know which peers are connected to the client.
//
// Format:
//
//    (UINT16) Peer Set
//
type PeerSet struct {
	PeerSet protocol.BitSet16
}

// Serialize encodes the struct into its binary form.
func (pkt *PeerSet) Serialize(buf *protocol.Buffer, enc *Encoding) error {
	buf.WriteUInt8(ProtocolSig)
	buf.WriteUInt8(PidPeerSet)
	buf.WriteUInt16(6)

	buf.WriteUInt16(uint16(pkt.PeerSet))

	return nil
}

// Deserialize decodes the binary data generated by Serialize.
func (pkt *PeerSet) Deserialize(buf *protocol.Buffer, enc *Encoding) error {
	if readPacketSize(buf) != 6 {
		return ErrInvalidPacketSize
	}

	pkt.PeerSet = protocol.BitSet16(buf.ReadUInt16())

	return nil
}

// MapCheck implements the [0x3D] W3GS_MapCheck packet (S -> C).
//
// This is sent from the game host to a client that just joined to check if the client has the map.
//
// Map hash is not only based on map file, as it takes common.j/blizzard.j from current patch into account as well.
//
// Format:
//
//    (UINT32)     Unknown (0x01)
//    (STRING)     File Path
//    (UINT32)     File size
//    (UINT32)     File CRC hash
//    (UINT32)     Map XOR/RotateLeft hash
//     (UINT8)[20] Map SHA-1 hash
//
type MapCheck struct {
	FilePath string
	FileSize uint32
	FileCRC  uint32
	MapXoro  uint32
	MapSha1  [20]byte
}

// Serialize encodes the struct into its binary form.
func (pkt *MapCheck) Serialize(buf *protocol.Buffer, enc *Encoding) error {
	buf.WriteUInt8(ProtocolSig)
	buf.WriteUInt8(PidMapCheck)
	buf.WriteUInt16(uint16(41 + len(pkt.FilePath)))

	buf.WriteUInt32(1)
	buf.WriteCString(pkt.FilePath)
	buf.WriteUInt32(pkt.FileSize)
	buf.WriteUInt32(pkt.FileCRC)
	buf.WriteUInt32(pkt.MapXoro)
	buf.WriteBlob(pkt.MapSha1[:])

	return nil
}

// Deserialize decodes the binary data generated by Serialize.
func (pkt *MapCheck) Deserialize(buf *protocol.Buffer, enc *Encoding) error {
	var size = readPacketSize(buf)
	if size < 41 {
		return ErrInvalidPacketSize
	}

	if buf.ReadUInt32() != 1 {
		return ErrUnexpectedConst
	}

	var err error
	if pkt.FilePath, err = buf.ReadCString(); err != nil {
		return err
	}

	if size != 41+len(pkt.FilePath) {
		return ErrInvalidPacketSize
	}

	pkt.FileSize = buf.ReadUInt32()
	pkt.FileCRC = buf.ReadUInt32()
	pkt.MapXoro = buf.ReadUInt32()
	copy(pkt.MapSha1[:], buf.ReadBlob(20))

	return nil
}

// StartDownload implements the [0x3F] W3GS_StartDownload packet (C -> S, S -> C).
//
// C -> S: Client sends this to the host to initiate a map download.
// S -> C: This tells the client that it is now in the downloading state and should expect chunks of file data.
//
// Format:
//
//    (UINT32) Unknown (0x01)
//     (UINT8) Player number
//
type StartDownload struct {
	PlayerID uint8
}

// Serialize encodes the struct into its binary form.
func (pkt *StartDownload) Serialize(buf *protocol.Buffer, enc *Encoding) error {
	buf.WriteUInt8(ProtocolSig)
	buf.WriteUInt8(PidStartDownload)
	buf.WriteUInt16(9)
	buf.WriteUInt32(1)
	buf.WriteUInt8(pkt.PlayerID)

	return nil
}

// Deserialize decodes the binary data generated by Serialize.
func (pkt *StartDownload) Deserialize(buf *protocol.Buffer, enc *Encoding) error {
	if readPacketSize(buf) != 9 {
		return ErrInvalidPacketSize
	}

	if buf.ReadUInt32() != 1 {
		return ErrUnexpectedConst
	}
	pkt.PlayerID = buf.ReadUInt8()

	return nil
}

// MapState implements the [0x42] W3GS_MapSize packet (C -> S).
//
// This is sent from the client to tell the host about the map file on the client'buf local system.
//
// Format:
//
//    (UINT32) Unknown (0x01)
//     (UINT8) Size Flag (0x01 is ready, 0x03 to request the next 0x43] W3GS_MapPart)
//    (UINT32) Map Size
//
type MapState struct {
	Ready    bool
	FileSize uint32
}

// Serialize encodes the struct into its binary form.
func (pkt *MapState) Serialize(buf *protocol.Buffer, enc *Encoding) error {
	buf.WriteUInt8(ProtocolSig)
	buf.WriteUInt8(PidMapSize)
	buf.WriteUInt16(13)

	buf.WriteUInt32(1)

	if pkt.Ready {
		buf.WriteUInt8(1)
	} else {
		buf.WriteUInt8(3)
	}

	buf.WriteUInt32(pkt.FileSize)

	return nil
}

// Deserialize decodes the binary data generated by Serialize.
func (pkt *MapState) Deserialize(buf *protocol.Buffer, enc *Encoding) error {
	if readPacketSize(buf) != 13 {
		return ErrInvalidPacketSize
	}

	if buf.ReadUInt32() != 1 {
		return ErrUnexpectedConst
	}
	pkt.Ready = buf.ReadUInt8() == 1
	pkt.FileSize = buf.ReadUInt32()

	return nil
}

// MapPart implements the [0x43] W3GS_MapPart packet (S -> C).
//
// This is received when you are downloading a map from the host.
//
// You can calculate how many more chunks you have left based on the file size and the chunk position in file. You are done downloading when the chunk position in file (plus the size of the chunk) matches the file size received in 0x42 W3GS_MapSize.
//
// If the data does not match the CRC-32, you should send the host 0x45 W3GS_MapPartError, otherwise you should always send 0x44 W3GS_MapPartOK in reply to this packet.
//
// Format:
//
//     (UINT8)       To player number
//     (UINT8)       From player number
//    (UINT32)       Unknown (0x01)
//    (UINT32)       Chunk position in file
//    (UINT32)       CRC-32 checksum
//     (UINT8)[1442] Data
//
type MapPart struct {
	RecipientID uint8
	SenderID    uint8
	ChunkPos    uint32
	Data        []byte
}

// Serialize encodes the struct into its binary form.
func (pkt *MapPart) Serialize(buf *protocol.Buffer, enc *Encoding) error {
	buf.WriteUInt8(ProtocolSig)
	buf.WriteUInt8(PidMapPart)
	buf.WriteUInt16(uint16(18 + len(pkt.Data)))

	buf.WriteUInt8(pkt.RecipientID)
	buf.WriteUInt8(pkt.SenderID)
	buf.WriteUInt32(1)
	buf.WriteUInt32(pkt.ChunkPos)

	buf.WriteUInt32(uint32(crc32.ChecksumIEEE(pkt.Data)))
	buf.WriteBlob(pkt.Data)

	return nil
}

// Deserialize decodes the binary data generated by Serialize.
func (pkt *MapPart) Deserialize(buf *protocol.Buffer, enc *Encoding) error {
	var size = readPacketSize(buf)
	if size < 18 {
		return ErrInvalidPacketSize
	}

	pkt.RecipientID = buf.ReadUInt8()
	pkt.SenderID = buf.ReadUInt8()

	if buf.ReadUInt32() != 1 {
		return ErrUnexpectedConst
	}

	pkt.ChunkPos = buf.ReadUInt32()

	var crc = buf.ReadUInt32()
	pkt.Data = append(pkt.Data[:0], buf.ReadBlob(size-18)...)
	if crc != uint32(crc32.ChecksumIEEE(pkt.Data)) {
		return ErrInvalidChecksum
	}

	return nil
}

// MapPartOK implements the [0x44] W3GS_MapPartOK packet (C -> S).
//
// The client sends this when it has successfully received a chunk of the map file from the host client.
//
// Format:
//
//     (UINT8) From player number
//     (UINT8) To player number
//    (UINT32) Unknown (0x01)
//    (UINT32) Chunk position in file
//
type MapPartOK struct {
	SenderID    uint8
	RecipientID uint8
	ChunkPos    uint32
}

// Serialize encodes the struct into its binary form.
func (pkt *MapPartOK) Serialize(buf *protocol.Buffer, enc *Encoding) error {
	buf.WriteUInt8(ProtocolSig)
	buf.WriteUInt8(PidMapPartOK)
	buf.WriteUInt16(14)

	buf.WriteUInt8(pkt.SenderID)
	buf.WriteUInt8(pkt.RecipientID)
	buf.WriteUInt32(1)
	buf.WriteUInt32(pkt.ChunkPos)

	return nil
}

// Deserialize decodes the binary data generated by Serialize.
func (pkt *MapPartOK) Deserialize(buf *protocol.Buffer, enc *Encoding) error {
	if readPacketSize(buf) != 14 {
		return ErrInvalidPacketSize
	}

	pkt.SenderID = buf.ReadUInt8()
	pkt.RecipientID = buf.ReadUInt8()

	if buf.ReadUInt32() != 1 {
		return ErrUnexpectedConst
	}
	pkt.ChunkPos = buf.ReadUInt32()

	return nil
}

// MapPartError implements the [0x45] W3GS_MapPartError packet (C -> S).
//
// This is sent when downloading a map in reply to 0x43 W3GS_MapPart and a chunk of the map file does not match its CRC checksum.
//
// Format:
//
//    [unknown]
//
type MapPartError struct {
	// Empty
}

// Serialize encodes the struct into its binary form.
func (pkt *MapPartError) Serialize(buf *protocol.Buffer, enc *Encoding) error {
	buf.WriteUInt8(ProtocolSig)
	buf.WriteUInt8(PidMapPartError)
	buf.WriteUInt16(4)

	return nil
}

// Deserialize decodes the binary data generated by Serialize.
func (pkt *MapPartError) Deserialize(buf *protocol.Buffer, enc *Encoding) error {
	if readPacketSize(buf) != 4 {
		return ErrInvalidPacketSize
	}
	return nil
}

// PlayerExtra implements the [0x59] protobuf packet (C -> S, S -> C).
//
// Sub packet is encoded in protobuf.
//
// Format:
//
//      (UINT8)    Sub type (0x03)
//                   0x02   Unknown, found when leaving LAN game
//                   0x03   Battle.net profile data
//                   0x04   In-game skins
//                   0x05   Unknown, found when joining LAN game
//     (UINT32)    Number of bytes following
//      (UINT8)[n] Protobuf encoded struct
//
//   For each battle.net profile (sub type 0x03, encoded with protobuf):
//      (UINT8) Player ID
//     (STRING) Battletag
//     (STRING) Clan
//     (STRING) Portrait
//      (UINT8) Team
//     (STRING) Unknown
//
//   For each player (sub type 0x04, encoded with protobuf):
//      (UINT8) Player ID
//      For each in-game skin:
//     (UINT64) Unit ID
//     (UINT64) Skin ID
//     (STRING) Skin collection
//
//   For sub type 0x05 (encoded with protobuf):
//      (UINT8) Player ID
//     (UINT32) Unknown
//
type PlayerExtra struct {
	Type     PlayerExtraType
	Profiles []PlayerDataProfile
	Skins    []PlayerDataSkins
	Unknown5 []PlayerData5
}

// PlayerDataProfile stores the info for a single battle.net player profile.
//
// Format (protobuf):
//
//      (UINT8) Player ID
//     (STRING) Battletag
//     (STRING) Clan
//     (STRING) Portrait
//      (UINT8) Team
//     (STRING) Unknown
//
type PlayerDataProfile struct {
	PlayerID  uint32
	BattleTag string
	Clan      string
	Portrait  string
	Realm     ProfileRealm
	Unknown1  string
}

// PlayerDataSkins stores the in-game skin usage for a single player.
//
// Format (protobuf):
//
//      (UINT8) Player ID
//
//      For each in-game skin:
//         (UINT64) Unit ID
//         (UINT64) Skin ID
//         (STRING) Skin collection
//
type PlayerDataSkins struct {
	PlayerID uint32
	Skins    []PlayerDataSkin
}

// PlayerDataSkin stores in-game skin info.
//
// Format (protobuf):
//
//     (UINT64) Unit ID
//     (UINT64) Skin ID
//     (STRING) Skin collection
//
type PlayerDataSkin struct {
	Unit       uint64
	Skin       uint64
	Collection string
}

// PlayerData5 stores the info for a single battle.net player profile.
//
// Format (protobuf):
//
//      (UINT8) Player ID
//     (UINT32) Unknown
//
type PlayerData5 struct {
	PlayerID uint32
	Unknown1 uint32
}

// Serialize encodes the struct into its binary form.
func (pkt *PlayerExtra) Serialize(buf *protocol.Buffer, enc *Encoding) error {
	var start = buf.Size()
	buf.WriteUInt8(ProtocolSig)
	buf.WriteUInt8(PidPlayerExtra)

	// Placeholder for size
	buf.WriteUInt16(0)

	if err := pkt.SerializeContent(buf, enc); err != nil {
		return err
	}

	buf.WriteUInt16At(start+2, uint16(buf.Size()-start))
	return nil
}

// Deserialize decodes the binary data generated by Serialize.
func (pkt *PlayerExtra) Deserialize(buf *protocol.Buffer, enc *Encoding) error {
	var start = buf.Size()
	var size = readPacketSize(buf)
	if size < 6 {
		return ErrInvalidPacketSize
	}

	if err := pkt.DeserializeContent(buf, enc); err != nil {
		return err
	}

	if size != (start - buf.Size()) {
		return ErrInvalidPacketSize
	}

	return nil
}

// SerializeContent encodes the struct into its binary form without packet ID.
func (pkt *PlayerExtra) SerializeContent(buf *protocol.Buffer, enc *Encoding) error {
	var raw []byte
	var err error
	switch pkt.Type {
	case PlayerExtra2:
		// Unknown format:
		//   0a60080610031a0a08efd09dab07100018011a0a08efc685ab07100018061a0808e7d2e
		//   9ab0718011a0808e4de85ab0718011a0808ece0b9ab0718011a0808ecde9dab0718011a
		//   0808f0cacdab0718011a0808edded1ab0718012a060800100018000a4a080710041a0a0
		//   8f0e6ddab061000180a1a0808ecded1ab0618011a0808ecde9dab0618011a0808e5e885
		//   ab0618011a0808edde85ab0618011a0808f7deb5ab0618012a06080010001800
		//
		//   0a4c080610031a0a08efd09dab07100018011a0a08efc685ab07100018031a0808e7d2e
		//   9ab0718011a0808e4de85ab0718011a0808ece0b9ab0718011a0808ecde9dab0718012a
		//   060800100018000a36080710041a0a08f0e6ddab06100018051a0808ecded1ab0618011
		//   a0808ecde9dab0618011a0808e5e885ab0618012a06080010001800
	case PlayerProfile:
		if len(pkt.Profiles) == 1 {
			raw, err = protobuf.Encode(&pkt.Profiles[0])
		} else {
			var tmp = struct {
				Profiles []PlayerDataProfile
			}{pkt.Profiles}
			raw, err = protobuf.Encode(&tmp)
		}
	case PlayerSkins:
		if len(pkt.Skins) == 1 {
			raw, err = protobuf.Encode(&pkt.Skins[0])
		} else {
			var tmp = struct {
				Skins []PlayerDataSkins
			}{pkt.Skins}
			raw, err = protobuf.Encode(&tmp)
		}
	case PlayerExtra5:
		if len(pkt.Unknown5) == 1 {
			raw, err = protobuf.Encode(&pkt.Unknown5[0])
		} else {
			var tmp = struct {
				Unknown5 []PlayerData5
			}{pkt.Unknown5}
			raw, err = protobuf.Encode(&tmp)
		}
	}

	if err != nil {
		return err
	}

	buf.WriteUInt8(uint8(pkt.Type))
	buf.WriteUInt32(uint32(len(raw)))
	buf.WriteBlob(raw)

	return nil
}

// DeserializeContent decodes the binary data generated by SerializeContent.
func (pkt *PlayerExtra) DeserializeContent(buf *protocol.Buffer, enc *Encoding) error {
	if buf.Size() < 5 {
		return io.ErrShortBuffer
	}

	pkt.Type = PlayerExtraType(buf.ReadUInt8())
	var size = int(buf.ReadUInt32())
	if size == 0 {
		return nil
	} else if buf.Size() < size {
		return io.ErrShortBuffer
	}

	pkt.Profiles = pkt.Profiles[:0]
	pkt.Skins = pkt.Skins[:0]
	pkt.Unknown5 = pkt.Unknown5[:0]

	var raw = buf.ReadBlob(size)
	switch pkt.Type {
	case PlayerProfile:
		var single PlayerDataProfile
		var repeat struct {
			Profiles []PlayerDataProfile
		}
		if err := protobuf.Decode(raw, &single); err == nil {
			pkt.Profiles = []PlayerDataProfile{single}
		} else if err := protobuf.Decode(raw, &repeat); err == nil {
			pkt.Profiles = repeat.Profiles
		} else {
			return err
		}
	case PlayerSkins:
		var single PlayerDataSkins
		var repeat struct {
			Skins []PlayerDataSkins
		}
		if err := protobuf.Decode(raw, &single); err == nil {
			pkt.Skins = []PlayerDataSkins{single}
		} else if err := protobuf.Decode(raw, &repeat); err == nil {
			pkt.Skins = repeat.Skins
		} else {
			return err
		}
	case PlayerExtra5:
		var single PlayerData5
		var repeat struct {
			Unknown5 []PlayerData5
		}
		if err := protobuf.Decode(raw, &single); err == nil {
			pkt.Unknown5 = []PlayerData5{single}
		} else if err := protobuf.Decode(raw, &repeat); err == nil {
			pkt.Unknown5 = repeat.Unknown5
		} else {
			return err
		}
	default:
		return ErrUnexpectedConst
	}

	return nil
}
